/********************************************
***** REQUIRES MODIFIED DRACULA TO WORK *****
****** included in Required Files zip *******
******** AMX Mod X 1.75 and up ONLY *********
********************************************/

// BLADE! from Marvel Comics and the Movie series. "Daywalker" the half vampire half human that hunts vampires.

/* CVARS - copy and paste to shconfig.cfg

//Blade
blade_level 5
blade_speed 350		//How fast he runs with knife, usp, or mac10 (Default 350)
blade_knifeburns 8	//Amount of burns from a knife attack, set to -1 for continuous burn (Default 8)
blade_knifeburndmg 5	//Amount of damage per burn from knife burn (Default 5)
blade_gunburns 5 	//Amount of burns from a usp/mac10 attack (Default 5)
blade_gunburndmg 3	//Amount of damage per burn from gun burn (Default 3)

*/

/*
* v1.1 - vittu - 5/3/06
*      - Cleaned up and recoded.
*      - Modified Dracula so Blade can actually work, included with download. (sh_dracula v1.18m)
*      - Changed glock to mac10 (since that's what he uses), with optional model. 
*      - Changed damage to be determined by number of burns.
*      - Changed scream sound.
*      - Fixed and changed speed to work with knife, usp, and mac10.
*      - Removed knife damage multiplier against non-dracula's.
*
*   Hero Created by TreDizzle and AssKicR (Burn code based on Human Torch)
*   Optional MAC10 weapon model reskinned by RCCSTEBB with DSFCHOOT's help (orginal by Ghost Ops Team, Strykerwolf, and Edisleado)
*/

//---------- User Changeable Defines --------//



// Note: If you change anything from default setting you must recompile the plugin

// Unlimited ammo
// 0 = no reload, 1 = drop weapon, 3 = disable unlimited ammo [Default 3]
#define AMMO_MODE 3

// 0 = don't use custom MAC10 model, 1 = use custom MAC10 model [Default 0]
#define USE_MODEL 0

// 0 = don't give free weapons, 1 = give free mac10 and usp(if T) [Default 0]
#define GIVE_WEAPONS 0



//------- Do not edit below this point ------//

#include <amxmodx>
#include "../my_include/superheromod.inc"

#if USE_MODEL
	#include <fakemeta>
#endif

// GLOBAL VARIABLES
new HeroName[] = "Blade"
new bool:HasBlade[SH_MAXSLOTS+1]
new bool:InKnifeBurn[SH_MAXSLOTS+1]
new bool:InGunBurn[SH_MAXSLOTS+1]
new VampForward
new SpriteSmoke, SpriteFire
new CvarKnifeDmg, CvarKnifeBurns, CvarGunDmg, CvarGunBurns
//----------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Blade", "1.1", "TreDizzle/AssKicR/vittu")

	// Create a forward to be called to check if a user has a vampire hero
	VampForward = CreateMultiForward("sh_is_vampire", ET_CONTINUE, FP_CELL)

	// Execute the forward to check if we have a valid function from another hero, if not stop the plugin from registering with SH
	new functionReturn
	ExecuteForward(VampForward, functionReturn, 0)

	switch(functionReturn)
	{
		case 0:
		{
			// 0 was returned so sh_is_vampire function was not found... stop this plugin and report an error else register it
			debugMessage("Function sh_is_vampire not found! No plugin found with the function, hero has been disabled.", 0, 0)
			set_fail_state("Function sh_is_vampire not found! No plugin found with the function, hero has been disabled. (plugin ^"sh_blade.amxx^")")
		}

		default:
		{
			// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
			register_cvar("blade_level", "5")
			register_cvar("blade_speed", "350")
			CvarKnifeBurns = register_cvar("blade_knifeburns", "8")
			CvarKnifeDmg = register_cvar("blade_knifeburndmg", "5")
			CvarGunBurns = register_cvar("blade_gunburns", "5")
			CvarGunDmg = register_cvar("blade_gunburndmg", "3")

			// FIRE THE EVENT TO CREATE THIS SUPERHERO!
			shCreateHero(HeroName, "Silver Knife & Bullets", "Burn Vampires with your KNIFE or Deal Extra Burning Damage with your MAC10 or USP", false, "blade_level")

			// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
			// INIT
			register_srvcmd("blade_init", "blade_init")
			shRegHeroInit(HeroName, "blade_init")

			// EVENTS
			register_event("ResetHUD", "new_spawn", "b")
			register_event("CurWeapon", "weapon_change", "be", "1=1")
			register_event("Damage", "blade_damage", "b", "2!0")

			// Let Server know about the hero's varibles
			shSetShieldRestrict(HeroName)
			shSetMaxSpeed(HeroName, "blade_speed", "[7][16][29]")	
		}
	}
}
//----------------------------------------------------------------------------------------------
public plugin_precache()
{
	SpriteSmoke = precache_model("sprites/steam1.spr")
	SpriteFire = precache_model("sprites/xfire.spr")
	precache_sound("ambience/burning1.wav")
	precache_sound("controller/con_die2.wav")

	#if USE_MODEL
		precache_model("models/shmod/blade_v_mac10.mdl")
	#endif
}
//----------------------------------------------------------------------------------------------
public blade_init()
{
	// First Argument is an id
	new temp[6]
	read_argv(1, temp, 5)
	new id = str_to_num(temp)

	// 2nd Argument is 0 or 1 depending on whether the id has the hero
	read_argv(2, temp, 5)
	new hasPowers = str_to_num(temp)

#if GIVE_WEAPONS == 1
	// Reset thier shield restrict status
	// Shield restrict MUST be before weapons are given out
	shResetShield(id)
#endif

	switch(hasPowers)
	{
		case true:
		{
			HasBlade[id] = true

			if ( is_user_alive(id) )
			{
				#if GIVE_WEAPONS == 1
					blade_weapons(id)
				#endif

				#if USE_MODEL
					switch_model(id)
				#endif
			}
		}

		case false:
		{
			// Check is needed since this gets run on clearpowers even if user didn't have this hero
			if ( is_user_alive(id) && HasBlade[id] )
			{
				#if GIVE_WEAPONS == 1
					if ( cs_get_user_team(id) == CS_TEAM_T )
						engclient_cmd(id, "drop", "weapon_usp")

					engclient_cmd(id, "drop", "weapon_mac10")
				#endif

				shRemSpeedPower(id)
			}

			HasBlade[id] = false
		}
	}
}
//----------------------------------------------------------------------------------------------
public new_spawn(id)
{
	blade_reset(id)

#if GIVE_WEAPONS == 1
	if ( shModActive() && is_user_alive(id) && HasBlade[id] )
		set_task(0.1, "blade_weapons", id)
}
//----------------------------------------------------------------------------------------------
public blade_weapons(id)
{
	if ( !shModActive() || !is_user_alive(id) || !HasBlade[id] )
		return

	if ( cs_get_user_team(id) == CS_TEAM_T )
		shGiveWeapon(id, "weapon_usp")

	shGiveWeapon(id, "weapon_mac10")

#endif
}
//----------------------------------------------------------------------------------------------
#if USE_MODEL
switch_model(id)
{
	if ( !shModActive() || !is_user_alive(id) || !HasBlade[id] )
		return

	new clip, ammo, wpnid = get_user_weapon(id, clip, ammo)

	if ( wpnid == CSW_MAC10 )
		set_pev(id, pev_viewmodel2, "models/shmod/blade_v_mac10.mdl")
}
#endif
//----------------------------------------------------------------------------------------------
public weapon_change(id)
{
	if ( !shModActive() || !HasBlade[id] )
		return

	new wpnid = read_data(2)

	if ( wpnid != CSW_MAC10 )
		return

#if USE_MODEL
	switch_model(id)
#endif

#if AMMO_MODE < 3
	new clip = read_data(3)

	// Never Run Out of Ammo!
	if ( clip == 0 )
		shReloadAmmo(id, AMMO_MODE)
#endif
}
//----------------------------------------------------------------------------------------------
public blade_damage(id)
{
	if ( !shModActive() || !is_user_alive(id) )
		return

	new weapon, bodypart, attacker = get_user_attacker(id, weapon, bodypart)

	if ( attacker <= 0 || attacker > SH_MAXSLOTS )
		return

	if ( HasBlade[attacker] && is_user_alive(id) && is_user_vampire(id) )
	{
		switch(weapon)
		{
			case CSW_KNIFE:
			{
				// Make sure user is not already in a knifeburn
				if ( InKnifeBurn[id] )
					return

				set_knifeburn(id, attacker)
			}

			case CSW_MAC10, CSW_USP:
			{
				// Make sure user is not already in a gunburn
				if ( InGunBurn[id] )
					return

				set_gunburn(id, attacker)
			}
		}
	}
}
//----------------------------------------------------------------------------------------------
bool:is_user_vampire(id)
{
	if ( !shModActive() || !is_user_alive(id) )
		return false

	new bool:isVamp
	new functionReturn

	ExecuteForward(VampForward, functionReturn, id)

	// Forward will return the highest value, don't return 1 or 2 in function cause of return handled or handled_main
	// and 0 is used by continue and invalid return, so can't return a bool either.
	switch(functionReturn)
	{
		case 0:
		{
			debugMessage("Function sh_is_vampire not found! No plugin found with the function.", 0, 1)
		}
		case 3:
		{
			isVamp = false
		}
		case 4:
		{
			isVamp = true
		}
	}

	return isVamp
}
//----------------------------------------------------------------------------------------------
// Keep public for hero Longshot to call this
public set_knifeburn(id, attacker)
{
	if ( !shModActive() || !is_user_alive(id) || InKnifeBurn[id] )
		return

	// Extra checks for use with hero Longshot
	if ( !HasBlade[attacker] || !is_user_vampire(id) )
		return

	new knifeBurns = get_pcvar_num(CvarKnifeBurns)

	switch(knifeBurns)
	{
		case -1:
		{
			InKnifeBurn[id] = true

			new args[2]
			args[0] = id
			args[1] = attacker

			set_task(0.3, "knifeburn", id, args, 2, "b")
		}

		case 0:
			return

		default:
		{
			InKnifeBurn[id] = true

			new args[2]
			args[0] = id
			args[1] = attacker

			new Float:burnStopTime = knifeBurns * 0.3 + 0.6
			set_task(0.3, "knifeburn", id, args, 2, "a", knifeBurns)
			set_task(burnStopTime, "stop_knifeburn", id)	
		}
	}

	// If already burning no need to set sound again
	if ( !InGunBurn[id] )
		emit_sound(id, CHAN_STATIC, "ambience/burning1.wav", 1.0, ATTN_NORM, 0, PITCH_NORM)

	vampire_scream(id)
}
//----------------------------------------------------------------------------------------------
public knifeburn(args[])
{
	new id = args[0]
	new attacker = args[1]

	if ( !shModActive() || !is_user_alive(id) )
	{
		blade_reset(id)
		return
	}

	if ( InKnifeBurn[id] )
	{
		burn_effect(id)

		new knifeDmg = get_pcvar_num(CvarKnifeDmg)
		new hpAfterDmg = get_user_health(id) - knifeDmg

		// Prevents the shExtraDamage from saying you attacked a teammate for every cycle of the loop
		if ( hpAfterDmg <= 0 )
			shExtraDamage(id, attacker, knifeDmg, "silver knife")
		else
			set_user_health(id, hpAfterDmg)
	}
}
//----------------------------------------------------------------------------------------------
set_gunburn(id, attacker)
{
	if ( !shModActive() || !is_user_alive(id) || InGunBurn[id] )
		return

	new gunBurns = get_pcvar_num(CvarGunBurns)

	if ( gunBurns <= 0 )
		return

	InGunBurn[id] = true

	new args[2]
	args[0] = id
	args[1] = attacker

	new Float:burnStopTime = gunBurns * 0.3 + 0.6
	set_task(0.3, "gunburn", id, args, 2, "a", gunBurns)
	set_task(burnStopTime, "stop_gunburn", id)

	// If already burning no need to set sound again
	if ( !InKnifeBurn[id] )
		emit_sound(id, CHAN_STATIC, "ambience/burning1.wav", 1.0, ATTN_NORM, 0, PITCH_NORM)

	vampire_scream(id)
}
//----------------------------------------------------------------------------------------------
public gunburn(args[])
{
	new id = args[0]
	new attacker = args[1]

	if ( !shModActive() || !is_user_alive(id) )
	{
		blade_reset(id)
		return
	}

	if ( InGunBurn[id] )
	{
		burn_effect(id)

		new gunDmg = get_pcvar_num(CvarGunDmg)
		new hpAfterDmg = get_user_health(id) - gunDmg

		// Prevents the shExtraDamage from saying you attacked a teammate for every cycle of the loop
		if ( hpAfterDmg <= 0 )
			shExtraDamage(id, attacker, gunDmg, "silver bullet")
		else
			set_user_health(id, hpAfterDmg)
	}
}
//----------------------------------------------------------------------------------------------
burn_effect(id)
{
	if ( !is_user_connected(id) )
		return

	new rx, ry, rz, forigin[3]

	rx = random_num(-30, 30)
	ry = random_num(-30, 30)
	rz = random_num(-30, 30)

	get_user_origin(id, forigin)

	//TE_SPRITE - additive sprite, plays 1 cycle
	message_begin(MSG_PVS, SVC_TEMPENTITY, forigin)
	write_byte(17)
	write_coord(forigin[0]+rx)	// coord, coord, coord (position)
	write_coord(forigin[1]+ry)
	write_coord(forigin[2]+10+rz)
	write_short(SpriteFire)	// short (sprite index)
	write_byte(30)		// byte (scale in 0.1's)
	write_byte(200)		// byte (brightness)
	message_end()

	//Smoke
	message_begin(MSG_PVS, SVC_TEMPENTITY, forigin)
	write_byte(5)
	write_coord(forigin[0]+(rx*2))	// coord, coord, coord (position)
	write_coord(forigin[1]+(ry*2))
	write_coord(forigin[2]+100+(rz*2))
	write_short(SpriteSmoke)	// short (sprite index)
	write_byte(60)			// byte (scale in 0.1's)
	write_byte(15)			// byte (framerate)
	message_end()
}
//----------------------------------------------------------------------------------------------
vampire_scream(id)
{
	if ( is_user_connected(id) )
		emit_sound(id, CHAN_AUTO, "controller/con_die2.wav", 1.0, ATTN_NORM, 0, PITCH_HIGH)
}
//----------------------------------------------------------------------------------------------
public stop_knifeburn(id)
{
	// Check and seperate function prevents removing the burning sound if still in other burn type
	if ( !InGunBurn[id] && is_user_connected(id) )
		emit_sound(id, CHAN_STATIC, "ambience/burning1.wav", 1.0, ATTN_NORM, SND_STOP, PITCH_NORM)

	InKnifeBurn[id] = false
}
//----------------------------------------------------------------------------------------------
public stop_gunburn(id)
{
	// Check and seperate function prevents removing the burning sound if still in other burn type
	if ( !InKnifeBurn[id] && is_user_connected(id) )
		emit_sound(id, CHAN_STATIC, "ambience/burning1.wav", 1.0, ATTN_NORM, SND_STOP, PITCH_NORM)

	InGunBurn[id] = false
}
//----------------------------------------------------------------------------------------------
blade_reset(id)
{
	remove_task(id)

	if ( InKnifeBurn[id] )
		stop_knifeburn(id)

	if ( InGunBurn[id] )
		stop_gunburn(id)
}
//----------------------------------------------------------------------------------------------
public client_connect(id)
{
	HasBlade[id] = false

	blade_reset(id)
}
//----------------------------------------------------------------------------------------------