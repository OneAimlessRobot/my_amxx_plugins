// Wildcard! - The Main Man of the Matrix

/* CVARS - copy and paste to shconfig.cfg

//Wildcard
wildcard_level 15
wildcard_ak47mult 1.0		//Damage multiplyer for his AK47
wildcard_damage 20		//Damage AK47 burst fire does
wildcard_radius 50		//Radius of the burst fire bullets

*/

#include "../my_include/superheromod.inc"
//#include <ostk_tools>

#define MAX_WEAPONS       30   // --| Max number of weapons. ( cs1.6/cz )

#define sg_start_reload   5    // --| Shotgun start reload sequence.
#define m_iId             43   // --| Weapon offset. ( return CSW_* )
#define m_fInReload       54   // --| Weapon offset.

#define CANT_RELOAD_BITSUM  ( 1 << CSW_HEGRENADE | 1 << CSW_SMOKEGRENADE | 1<<CSW_FLASHBANG | 1 << CSW_KNIFE | 1 << CSW_C4 )
#define SHOTGUNS_BITSUM     ( 1 << CSW_XM1014 | 1 << CSW_M3 )

// GLOBAL VARIABLES
new gHeroID
new const gHeroName[] = "Wildcard"
new const gEntAKBurst[] = "akBurst"
new const gModelShell[] = "models/rshell_big.mdl"
new bool:gHasWildcard[SH_MAXSLOTS+1]
new g_burst_waittime[33] = 0
new g_burst_reloadtime[33] = 0
new gMaxPlayers
new pCvarAK47Mult, gPcvarMaxDamage, gPcvarRadius, gPcvarSpeed
//----------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Wildcard", SH_VERSION_STR, "1sh0t2killz")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvarLevel = register_cvar("wildcard_level", "15")
	pCvarAK47Mult = register_cvar("wildcard_ak47mult", "1.0")
	gPcvarMaxDamage = register_cvar("wildcard_damage", "20")
	gPcvarRadius = register_cvar("wildcard_radius", "50")
	gPcvarSpeed = register_cvar("wildcard_speed", "2000.0")

	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvarLevel)
	sh_set_hero_info(gHeroID, "Burst fire AK47", "Use ATTACK2 with your ak47 to shoot 5 bullets at once, those bullets also follow your crosshair.")

	// REGISTER EVENTS
	register_forward(FM_PlayerPreThink, "forward_playerprethink")
	register_forward(FM_Think, "fm_Think")
	register_forward(FM_Touch, "fm_Touch")
	
	gMaxPlayers = get_maxplayers()
	RegisterHamsReload ()
}
//----------------------------------------------------------------------------------------------
/*public plugin_natives()
{
	register_library("ostk_tools")

	register_native("set_user_weap_clip", "_set_user_weap_clip")
	register_native("get_user_weap_index", "_get_user_weap_index")
	register_native("get_user_weap_clip", "_get_user_weap_clip")	
}*/
//----------------------------------------------------------------------------------------------
public plugin_precache()
{ 
	precache_model(gModelShell)
	precache_sound("weapons/ak47-1.wav")
	precache_sound("weapons/ric_conc-1.wav")
	precache_sound("weapons/knife_hit3.wav")
}
//----------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode)
{
	if ( gHeroID != heroID ) return

	switch(mode) {
		case SH_HERO_ADD: {
			gHasWildcard[id] = true

			wildcard_weapons(id)
		}

		case SH_HERO_DROP: {
			gHasWildcard[id] = false
			if ( is_user_alive(id) ) {
				sh_drop_weapon(id, CSW_AK47, true)
			}
		}
	}

	sh_debug_message(id, 1, "%s %s", gHeroName, mode ? "ADDED" : "DROPPED")
}
//----------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
	if ( gHasWildcard[id] ) {
		wildcard_weapons(id)
		if (g_burst_waittime[id] > 1)
		{
			g_burst_waittime[id] = 1
		}
		if (g_burst_reloadtime[id] > 0)
		{
			g_burst_reloadtime[id] = 0
		}
	}
}
//----------------------------------------------------------------------------------------------
wildcard_weapons(id)
{
	if ( sh_is_active() && is_user_alive(id) && gHasWildcard[id] ) {
		sh_give_weapon(id, CSW_AK47)
	}
}
//----------------------------------------------------------------------------------------------
public client_damage(attacker, victim, damage, wpnindex, hitplace)
{
	if ( !sh_is_active() ) return
	if ( !is_user_alive(victim) || !is_user_connected(attacker) ) return

	if ( gHasWildcard[attacker] && wpnindex == CSW_AK47 ) {
		new headshot = hitplace == 1 ? 1 : 0

		// do extra damage
		new extraDamage = floatround(damage * get_pcvar_float(pCvarAK47Mult) - damage)
		if ( extraDamage > 0) sh_extra_damage(victim, attacker, extraDamage, "AK47", headshot)
	}
}
//----------------------------------------------------------------------------------------------
public fm_Think(ent)
{
	if ( !pev_valid(ent) ) return FMRES_IGNORED

	static classname[32]
	classname[0] = '^0'
	pev(ent, pev_classname, classname, 31)

	if ( !equal(classname, gEntAKBurst) ) return FMRES_IGNORED

	new id = pev(ent, pev_owner)

	if ( !is_user_connected(id) ) {
		fm_Touch(ent, 0)
		return FMRES_IGNORED
	}

	new Float:fl_Origin[3], AimVec[3], Float:fl_EndOrigin[3], Float:fl_Velocity[3], Float:fl_OldVelocity[3]
	new avgFactor
	new Float:speed = 2000.0

	get_user_origin(id, AimVec, 3)
	IVecFVec(AimVec, fl_EndOrigin)
	pev(ent, pev_origin, fl_Origin)

	if ( speed < 1000.0 )
		avgFactor = 6
	else if ( speed < 1500.0 )
		avgFactor = 4
	else
		avgFactor = 2

	sh_get_velocity(fl_Origin, fl_EndOrigin, speed, fl_Velocity)

	pev(ent, pev_velocity, fl_OldVelocity)

	// Make it lag a bit, helps keep movement smooth else would be too erratic
	new oneless = avgFactor-1
	fl_Velocity[0] += fl_OldVelocity[0] * oneless
	fl_Velocity[1] += fl_OldVelocity[1] * oneless
	fl_Velocity[2] += fl_OldVelocity[2] * oneless

	fl_Velocity[0] /= avgFactor
	fl_Velocity[1] /= avgFactor
	fl_Velocity[2] /= avgFactor

	set_pev(ent, pev_velocity, fl_Velocity)

	/*new Float:gametime
	global_get(glb_time, gametime)
	set_pev(ent, pev_nextthink, gametime + 0.1)*/

	return FMRES_IGNORED
}
//----------------------------------------------------------------------------------------------
public fm_Touch(ptr, ptd)
{
	if ( !sh_is_active() ) return FMRES_IGNORED
	if ( !pev_valid(ptr) ) return FMRES_IGNORED

	static classname[32]
	classname[0] = '^0'
	pev(ptr, pev_classname, classname, 31)

	// Lets block the picking up of a shield
	if ( equal(classname, gEntAKBurst) ) {
		new id = pev(ptr, pev_owner)

		new Float:dRatio, Float:distanceBetween, damage
		new Float:dmgRadius = get_pcvar_float(gPcvarRadius)
		new maxDamage = get_pcvar_num(gPcvarMaxDamage)
		new CsTeams:idTeam = cs_get_user_team(id)
		new FFOn = sh_friendlyfire_on()
		new Float:vicOrigin[3]
		new Float:fl_vExplodeAt[3]

		pev(ptr, pev_origin, fl_vExplodeAt)

		for ( new victim = 1; victim <= gMaxPlayers; victim++ )
		{
			if ( !is_user_alive(victim) ) continue
			if ( idTeam == cs_get_user_team(victim) && !FFOn && id != victim ) continue

			pev(victim, pev_origin, vicOrigin)
			distanceBetween = vector_distance(fl_vExplodeAt, vicOrigin)

			if ( distanceBetween <= dmgRadius )
			{
				dRatio = distanceBetween / dmgRadius
				damage = maxDamage - floatround(maxDamage * dRatio)

				// Lessen damage taken by self
				if (victim == id) damage = floatround(damage / 2.0)

				if ( !damage ) damage = 1	// Incase damage cvar is really low cause something if within the radius 
				sh_extra_damage(victim, id, damage, "AK47 Burst", _, SH_DMG_NORM, true, _, fl_vExplodeAt)
				
				emit_sound(id, CHAN_VOICE, "weapons/knife_hit3.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM)
				emit_sound(ptr, CHAN_VOICE, "weapons/knife_hit3.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM)
			}
		}

		emit_sound(ptr, CHAN_VOICE, "weapons/ric_conc-1.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM)
		emit_sound(ptr, CHAN_VOICE, "weapons/ric_conc-1.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM)
		
		message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
		write_byte(TE_GUNSHOTDECAL)	//109
		engfunc(EngFunc_WriteCoord, fl_vExplodeAt[0])
		engfunc(EngFunc_WriteCoord, fl_vExplodeAt[1])
		engfunc(EngFunc_WriteCoord, fl_vExplodeAt[2])
		write_short(0)			//?
		write_byte(41)			//Bullet decal
		message_end()

		engfunc(EngFunc_RemoveEntity, ptr)
	}

	return FMRES_IGNORED
}
//----------------------------------------------------------------------------------------------
public forward_playerprethink(id)
{
	if(is_user_alive(id))
	{
		new clip, ammo, wpnid = get_user_weapon(id,clip,ammo)
		if (entity_get_int(id, EV_INT_button) & IN_ATTACK) return FMRES_IGNORED
		if (entity_get_int(id, EV_INT_button) & IN_RELOAD) return FMRES_IGNORED
		if (entity_get_int(id, EV_INT_button) & IN_ATTACK2 && wpnid == CSW_AK47 && gHasWildcard[id] )
		{
			wildcard_burst(id)
			return FMRES_IGNORED
		}
	}
	return FMRES_IGNORED
}
//----------------------------------------------------------------------------------------------
public Event_OnReload ( const i_WeaponIndex )
{
	// --| Called each time you use the reload key even when no need.
	// --| Called one time while the weapon is reloading.
	// --| Except for shotguns which will be called 3 times on reloading. ( one by ball )
	
	// --| Get the player's index.
	static id; id = pev ( i_WeaponIndex, pev_owner )
	
	// --| Make sure player is reloading and player is not alone.
	if ( UTIL_IsWeaponReloading ( id, i_WeaponIndex ) )
	{
		g_burst_reloadtime[id] = 1
		set_task( 3.0, "wildcard_burstreload", id)
	}
}
//----------------------------------------------------------------------------------------------
UTIL_IsWeaponReloading ( const id, const i_Ent )
{	
	// --| If we're holding a shotgun.
	if ( 1 << get_pdata_int ( i_Ent, m_iId, 4 ) & SHOTGUNS_BITSUM )
	{
		// --| We check its animation instead of m_fInSpecialReload because
		// --| Event_OnReload will be called 3 times by ball and it's a pain to
		// --| deal with that when we want to play the reload sound one time.
		if ( pev ( id, pev_weaponanim ) == sg_start_reload )  { return 1; }
	}
	
	// --| Other weapons.
	return get_pdata_int ( i_Ent, m_fInReload, 4 )
}
//----------------------------------------------------------------------------------------------
RegisterHamsReload ()
{
	// --| Need to loop through all weapons because Ham sucks. :p
	// --| As 'post' is necessary, otherwise the offset will not work.
	
	new s_WeaponName[ 24 ]
	
	for ( new i_Wpid = 1; i_Wpid <= MAX_WEAPONS; i_Wpid++ )
	{
		// --| Don't register item/weapons which can not reload.
		if ( !( ( 1 << i_Wpid ) & CANT_RELOAD_BITSUM ) && get_weaponname ( i_Wpid, s_WeaponName, charsmax ( s_WeaponName ) ) )
		{
			RegisterHam ( Ham_Weapon_Reload, s_WeaponName, "Event_OnReload", 1 )
		}
	}
}
//----------------------------------------------------------------------------------------------
public wildcard_burstreload(id)
{
	g_burst_reloadtime[id] = 0
}
//----------------------------------------------------------------------------------------------
public wildcard_burst(id)
{
	if( !gHasWildcard[id] || !(is_user_alive(id)) || g_burst_reloadtime[id] == 1 )
	return PLUGIN_CONTINUE

	if (halflife_time()-g_burst_waittime[id] < 1) return PLUGIN_CONTINUE
	g_burst_waittime[id] = floatround(halflife_time())	
	
	if(get_user_weap_clip(id) < 5)
	{
		client_print(id, print_center, "Not enough bullets")
		return PLUGIN_CONTINUE
	}

	wildcard_burstfx(id,0,0,0)
	wildcard_burstfx(id,-2,4,-10)
	wildcard_burstfx(id,-2,-8,-5)
	wildcard_burstfx(id,4,2,14)
	wildcard_burstfx(id,4,-12,7)

	new amount = get_user_weap_clip(id)
	
	set_user_weap_clip(id,CSW_AK47,amount-5)

	return PLUGIN_CONTINUE
}
//----------------------------------------------------------------------------------------------
public wildcard_burstfx(id,xcoord,zcoord,ycoord)
{	
	if (is_user_alive(id))
	{
		new newEnt = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"))
		if ( !newEnt ) {
			return PLUGIN_HANDLED
		}
		set_pev(newEnt, pev_classname, gEntAKBurst)
		engfunc(EngFunc_SetModel, newEnt, gModelShell)
		engfunc(EngFunc_SetSize, newEnt, {-0.1, -0.1, -0.1}, {0.1, 0.1, 0.1})

		new Float:fl_Origin[3], Float:fl_Angles[3], Float:fl_vAngle[3]
		// Get users postion and angles (angles are probably not needed in this case)
		pev(id, pev_origin, fl_Origin)
		pev(id, pev_angles, fl_Angles)
		pev(id, pev_v_angle, fl_vAngle)
		
		//This will make it so that the disk appears in front of the user	
		new Float:viewing_angles[3]
		new distance_from_user = 10
		entity_get_vector(id, EV_VEC_angles, viewing_angles)
		fl_Origin[0] += (floatcos(viewing_angles[1], degrees) * distance_from_user)+xcoord
		fl_Origin[1] += (floatsin(viewing_angles[1], degrees) * distance_from_user)+zcoord
		fl_Origin[2] += (floatsin(-viewing_angles[0], degrees) * distance_from_user)+ycoord
	
		// Set entity postion and angles
		engfunc(EngFunc_SetOrigin, newEnt, fl_Origin)
		set_pev(newEnt, pev_angles, fl_Angles)
		set_pev(newEnt, pev_v_angle, fl_vAngle)

		// Set properties of the entity
		set_pev(newEnt, pev_solid, SOLID_BBOX)
		set_pev(newEnt, pev_movetype, MOVETYPE_FLY)
		set_pev(newEnt, pev_rendermode, kRenderTransAdd)
		set_pev(newEnt, pev_renderamt, 255.0)
		set_pev(newEnt, pev_scale, 2.00)
		set_pev(newEnt, pev_owner, id)

		new Float:fl_Velocity[3], AimVec[3], Float:fl_EndOrigin[3]

		get_user_origin(id, AimVec, 3)
		IVecFVec(AimVec, fl_EndOrigin)
		
		fl_EndOrigin[0] += random_num(-10, 10)
		fl_EndOrigin[1] += random_num(-10, 10)
		fl_EndOrigin[2] += random_num(-10, 10)
	
		// Seting entSpeed higher then 2000.0 will require server to set sv_maxvelocity higher as well
		// sh_get_velocity verifies sv_maxvelocity is set high enough if not it will lower the speed
		sh_get_velocity(fl_Origin, fl_EndOrigin, get_pcvar_float(gPcvarSpeed), fl_Velocity)
	
		set_pev(newEnt, pev_velocity, fl_Velocity)
		
		emit_sound(newEnt, CHAN_VOICE, "weapons/ak47-1.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM)
		emit_sound(newEnt, CHAN_VOICE, "weapons/ak47-1.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM)
		emit_sound(id, CHAN_VOICE, "weapons/ak47-1.wav", VOL_NORM, ATTN_NORM, 0, PITCH_NORM)
	
		/*new Float:gametime
		global_get(glb_time, gametime)
		set_pev(newEnt, pev_nextthink, gametime + 0.1)*/
	}
	return PLUGIN_HANDLED
}
//----------------------------------------------------------------------------------------------
public eng_get_ent_by_class(entid, classname[])
{
	return engfunc(EngFunc_FindEntityByString, entid, "classname", classname);
}
//----------------------------------------------------------------------------------------------
//Natives
/*
public _get_user_weap_clip(plugin,params)
{
	if (params != 1)
		return 0
	
	new id = get_param(1)
	
	new clip, ammo
	
	get_user_weapon(id, clip, ammo)
	
	return clip
}
//----------------------------------------------------------------------------------------------
public _set_user_weap_clip(plugin,params)
{
	new id
	if(params>=1)
	{
		id = get_param(1)
		if(!is_user_alive(id))
			return 0
	}
	
	new weapid
	
	weapid = get_user_weap_index(id)
	
	if (params != 3)
	{
		return 0
	}
	
	weapid = get_param(2)
	new amount = get_param(3)
	
	if(weapid==CSW_C4||weapid==CSW_KNIFE)
		return 0
	
	new weapname[33]
	get_weaponname(weapid , weapname , 32)
	new weap = -1;
	
	while((weap = eng_get_ent_by_class(weap, weapname)) != 0)
	{
		if(id == pev(weap,pev_owner))
		{
			cs_set_weapon_ammo(weap , amount)
			break;
		}
	}
	
	return 1
}
//----------------------------------------------------------------------------------------------
public _get_user_weap_index(plugin,params)
{
	if (params != 1)
		return 0
	
	new id = get_param(1)
	
	new clip, ammo, weap
	
	weap = get_user_weapon(id, clip, ammo)
	
	return weap
}*/
//----------------------------------------------------------------------------------------------
public get_user_weap_clip(id)
{	
	new clip, ammo
	
	get_user_weapon(id, clip, ammo)
	
	return clip
}
//----------------------------------------------------------------------------------------------
public set_user_weap_clip(id,weapid,amount)
{
	if(!is_user_alive(id))
		return 0
	
	weapid = get_user_weap_index(id)
	
	if(weapid==CSW_C4||weapid==CSW_KNIFE)
		return 0
	
	new weapname[33]
	get_weaponname(weapid , weapname , 32)
	new weap = -1;
	
	while((weap = eng_get_ent_by_class(weap, weapname)) != 0)
	{
		if(id == pev(weap,pev_owner))
		{
			cs_set_weapon_ammo(weap , amount)
			break;
		}
	}
	
	return 1
}
//----------------------------------------------------------------------------------------------
public get_user_weap_index(id)
{	
	new clip, ammo, weap
	
	weap = get_user_weapon(id, clip, ammo)
	
	return weap
}
//----------------------------------------------------------------------------------------------
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1033\\ f0\\ fs16 \n\\ par }
*/
